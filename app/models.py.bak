$utf8NoBom = New-Object System.Text.UTF8Encoding($false)
[System.IO.File]::WriteAllText("$pwd\app\models.py", @'
from __future__ import annotations

from datetime import datetime
from enum import Enum
from typing import Optional

from sqlalchemy import (
    Column,
    Integer,
    String,
    DateTime,
    Boolean,
    Text,
    ForeignKey,
    Enum as SAEnum,
    JSON,
    Index,
    UniqueConstraint,
    CheckConstraint,
    func,
)
from sqlalchemy.orm import relationship

from .database import Base


# ---------- Mixins ----------
class TimestampMixin:
    created_at = Column(DateTime, nullable=False, server_default=func.now())
    updated_at = Column(DateTime, nullable=False, server_default=func.now(), onupdate=func.now())


# ---------- Enums ----------
class JobStatus(str, Enum):
    queued = "queued"
    processing = "processing"
    done = "done"
    error = "error"


class UsageReason(str, Enum):
    job_charge = "job_charge"
    admin_adjust = "admin_adjust"
    grant_cycle = "grant_cycle"
    refund = "refund"


# ---------- Models ----------
class User(Base, TimestampMixin):
    __tablename__ = "users"

    id = Column(Integer, primary_key=True)
    email = Column(String, unique=True, index=True, nullable=True)
    display_name = Column(String, nullable=True)

    # Suscripción / Billing
    plan_tier = Column(String, nullable=False, default="free")  # free|basic|pro|unlimited|teams
    paypal_subscription_id = Column(String, nullable=True, index=True)
    cycle_start = Column(DateTime, nullable=True)
    cycle_end = Column(DateTime, nullable=True)

    # Cuotas (minutos por ciclo)
    minute_quota = Column(Integer, nullable=False, default=0)
    minutes_used = Column(Integer, nullable=False, default=0)

    # Estado
    is_active = Column(Boolean, nullable=False, default=True)

    # Relaciones
    jobs = relationship(
        "AudioJob",
        back_populates="user",
        cascade="all, delete-orphan",
        passive_deletes=True,
    )
    usage_events = relationship(
        "UsageLedger",
        back_populates="user",
        cascade="all, delete-orphan",
        passive_deletes=True,
        order_by="desc(UsageLedger.created_at)",
    )

    def __repr__(self) -> str:
        return f"<User id={self.id} plan={self.plan_tier} used={self.minutes_used}/{self.minute_quota}>"

    @property
    def minutes_remaining(self) -> int:
        rem = int(self.minute_quota or 0) - int(self.minutes_used or 0)
        return rem if rem > 0 else 0

    def add_minutes(self, delta: int) -> None:
        self.minutes_used = max(0, int(self.minutes_used or 0) + int(delta or 0))


class AudioJob(Base, TimestampMixin):
    """Job de transcripción/síntesis."""
    __tablename__ = "audio_jobs"

    id = Column(Integer, primary_key=True)

    # Propietario
    user_id = Column(Integer, ForeignKey("users.id", ondelete="CASCADE"), index=True, nullable=False)
    user = relationship("User", back_populates="jobs")

    # Origen / archivo
    original_filename = Column(String, nullable=True)
    audio_s3_key = Column(String, nullable=True)
    local_path = Column(String, nullable=True)
    mime_type = Column(String, nullable=True)
    size_bytes = Column(Integer, nullable=True)

    # Estado del procesamiento
    status = Column(SAEnum(JobStatus), nullable=False, default=JobStatus.queued)
    error_message = Column(Text, nullable=True)

    # Idioma
    language_forced = Column(String(8), nullable=True)
    language_detected = Column(String(8), nullable=True)

    # Duración y modelo
    duration_seconds = Column(Integer, nullable=True, index=True)
    model_used = Column(String, nullable=True)

    # Resultados
    transcript = Column(Text, nullable=True)
    summary_json = Column(JSON, nullable=True)

    # Costeo opcional
    cost_cents = Column(Integer, nullable=True)

    __table_args__ = (
        CheckConstraint("length(language_forced) <= 8", name="ck_jobs_lang_forced_len"),
        CheckConstraint("length(language_detected) <= 8", name="ck_jobs_lang_detected_len"),
    )

    def __repr__(self) -> str:
        return f"<AudioJob id={self.id} user={self.user_id} status={self.status} dur={self.duration_seconds}s>"


class UsageLedger(Base, TimestampMixin):
    """Libro mayor de consumo/asignación de minutos (eventos por job/ajuste)."""
    __tablename__ = "usage_ledger_events"  # tabla creada por migración 20250820_usage_events

    id = Column(Integer, primary_key=True)

    user_id = Column(Integer, ForeignKey("users.id", ondelete="CASCADE"), index=True, nullable=False)
    user = relationship("User", back_populates="usage_events")

    job_id = Column(Integer, ForeignKey("audio_jobs.id", ondelete="SET NULL"), nullable=True, index=True)
    minutes_delta = Column(Integer, nullable=False, default=0)   # + consumo ; - abono
    reason = Column(SAEnum(UsageReason), nullable=False, default=UsageReason.job_charge)
    note = Column(String, nullable=True)

    __table_args__ = (
        Index("ix_usage_events_user_created", "user_id", "created_at"),
    )

    def __repr__(self) -> str:
        return f"<UsageLedger user={self.user_id} delta={self.minutes_delta} reason={self.reason}>"


class PaymentEvent(Base, TimestampMixin):
    """Eventos de PayPal procesados (idempotencia + auditoría)."""
    __tablename__ = "payment_events"

    id = Column(Integer, primary_key=True)
    provider = Column(String, nullable=False, default="paypal")
    event_type = Column(String, nullable=False)
    external_event_id = Column(String, nullable=False)
    subscription_id = Column(String, nullable=True, index=True)
    payload = Column(JSON, nullable=True)

    __table_args__ = (
        UniqueConstraint("provider", "external_event_id", name="uq_payment_events_provider_event"),
        Index("ix_payment_sub_id_created", "subscription_id", "created_at"),
    )

    def __repr__(self) -> str:
        return f"<PaymentEvent {self.provider}:{self.event_type} id={self.external_event_id}>"
'@, $utf8NoBom)
